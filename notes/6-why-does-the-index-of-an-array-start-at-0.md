# 6 为什么数组的索引从 0 开始

> 不要让数据结构的特性成为我们处理问题的限制。比如，数组的内存是连续分配的。我们无法改变数组内存在物理上的连续性，但是我们可以从逻辑的角度打破这种连续性。

## 线性表和非线性表的简要介绍

* 线性表：线性表上的每个元素，最多只有一个前驱元素和后继元素。数组、链表、栈、队列都是线性表。
* 非线性表：非线性表上的每个元素，其前驱元素和后继元素的个数要比线性表更复杂。树、图、堆都属于非线性表。

![linear table](../images/linear-table.jpg)
![nonlinear table](../images/nonlinear-table.jpg)

## 数组

> 数组不仅仅是编程语言中的一种数据类型，更是一种基础数据结构。

数组的定义：**数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组相同类型的数据。**

### 数组的特点

* 线性表
* 连续的内存空间
* 存储相同类型数据
* 具备随机访问特性

## 随机访问的时间复杂度

数组具备随机访问的特性，根据下标进行随机访问的时间复杂度是 O(1)。以下是数组随机访问时所使用的寻址计算公式，其中，**数组中的索引值 `i` 表示偏移量**。

```
a[i]_address = base_address + i * data_type_size
```

关于数组的随机访问，有一种错误的说法：数组适合查找，其查找时间复杂度为 O(1)。

### 数组的索引值为什么从 0 开始

如果数组的索引值从 1 开始，那么上述的寻址计算公式就变成了：

```
a[i]_address = base_address + (i - 1) * data_type_size
```

这样一来，每次随机访问都会多出一次减法运算。

## 数组插入元素的时间复杂度

假设数组所占内存空间为 m，数组元素个数为 n，且 n 小于 m，那么向数组插入元素的时间复杂度的分析如下。

### 最好情况时间复杂度

向 index = n 的位置插入，此时为最好时间复杂度，即 O(1)。

### 最坏情况时间复杂度

向 index = 0 的位置插入，此时为最坏时间复杂度，即 O(n)。

### 平均情况时间复杂度

向 index 范围为 [0, n] 的位置插入，共有 n + 1 种情况，且每一种情况发生的概率相同，那么时间复杂度的计算公式为 `(0 + 1 + 2 + ... + n)/(n + 1)`，即 O(n)。

### 特殊情况下的优化方法

当向数组插入元素且不需要保证数组原有的顺序，那么向 index = k 位置插入元素时，可以将原来位于 index = k 的元素插入到数组的最后，然后再往 index = k 的位置插入元素。这种插入方式的时间复杂度为 O(1)。

## 数组删除元素的时间复杂度

假设数组所占内存空间为 m，数组元素个数为 n，且 n 小于 m，那么删除数组元素的时间复杂度的分析如下。

### 最好情况时间复杂度

删除 index = n - 1 位置上的元素，时间复杂度为 O(1)。

### 最坏情况时间复杂度

删除 index = 0 位置上的元素，时间复杂度为 O(n)。

### 平均情况时间复杂度

删除 index 范围为 [0, n-1] 位置上的元素，共有 n 种情况，且每一种情况发生的概率相同，那么时间复杂度的计算公式为：`(0 + 1 + ... + n - 1)/n`，即 O(n)。 

### 删除数组元素的优化办法

如果不追求数组元素的连续性，那么删除数组元素时，可以连续删除若干个元素并且记下这些元素的索引值，当数组空间不够时，再进行真正的删除操作。这种方式可以减少删除元素带来的数据迁移操作。

## 数组 VS 容器类

数组是一种非常基础的数据结构，容器类如 ArrayList 则是将许多数组操作的细节封装起来，比如支持动态扩容、插入或删除元素时进行元素的迁移等。但在对性能极高的场景，如开发网络框架，数组可以对性能优化得更好。

## 数组越界问题

尽管数组是一种非常基础的数据结构，但是不同的编程语言对数组的有些操作细节可能是不同的。比如，C 语言中需要程序员去检测数组越界的问题，但 Java 本身就会做越界检查。
